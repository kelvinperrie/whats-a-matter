
<!DOCTYPE html>
<html lang="en-nz">
    <head>
        <title>fff</title>
        <style>
            html, body {
                margin: 0 !important;
                padding: 0 !important;
            }
            #canvas {
                position:fixed;
                /* left:0;
                top:0;
                width:100%;
                height:100%; */
            }
            #text {
                position: absolute;
                color: #D9A114;
                /* background-color: red; */
                z-index: 20;
                font-size: 2em;
                margin: 20px;
                user-select: none;
            }
            .title {
                font-size: 1.5em;;
            }
            .value-display {
                font-size: 1.5em;
            }
            .indent {
                margin-left: 40px;
            }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.js"></script>
    </head>
    <body>

        <canvas id="canvas"></canvas>
        <div id="text">
            When you click it will create a circle.<br/>
            Cool.<br/>
            If you want you can turn on autocreation by pressing space. Currently it is <span class="value-display" id="autoCreationDisplay">??</span> <br/>
            This will create a circle where the mouse is; currently every <span class="value-display" id="speedDisplay">??</span> milliseconds. 
            <div class="indent">
                To speed it up press A. To slow it down press Z.<br/>
            </div>
            The size of the circle is currently <span class="value-display" id="sizeDisplay">??</span>. 
            <div class="indent">
                To increase it press S. To decrease it press X.
            </div>
        </div>
        <script>

            var Engine = Matter.Engine,
                Render = Matter.Render,
                Runner = Matter.Runner,
                Common = Matter.Common,
                MouseConstraint = Matter.MouseConstraint,
                Mouse = Matter.Mouse,
                Composite = Matter.Composite,
                Vertices = Matter.Vertices,
                Svg = Matter.Svg,
                Bodies = Matter.Bodies;

            var mousePosition = { x:null, y:null };

            var groundHeight = 1000;    // if we make the ground really thick, then when resizing the window our objects should stay on screen rather than popping below the ground
            var bodySize = 15;
            var autoCreationActive = false;

            (function() {

                var canvas = document.getElementById('canvas');
   
                engine = Engine.create({
                    
                });

                // create a renderer
                var render = Render.create({
                    element: document.body,
                    canvas: canvas,
                    engine: engine,
                    options: {wireframes: false}
                });

                // run the renderer
                Render.run(render);

                // create runner
                var runner = Runner.create();

                // run the engine
                Runner.run(runner, engine);

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                window.addEventListener("resize", function(){
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    Matter.Body.setPosition(ground, { x : window.innerWidth / 2, y : window.innerHeight + (groundHeight/2) })
                    // potentially the ground won't reach the whole width unless we scale it?
                });

                
                var ground = Bodies.rectangle(window.innerWidth / 2, window.innerHeight + (groundHeight/2), window.innerWidth * 10, groundHeight, { isStatic: true });
                
                Composite.add(engine.world, [ground]);
        
            })();



            function MakeCircle(xPos, yPos) {
                var circleA = Bodies.circle(xPos, yPos, bodySize, {
                render: {
                    fillStyle: '#30D930', // 3C8BC5
                    //lineWidth: 3
                }
                });
                
                Matter.World.add(engine.world, [
                    circleA
                ]);
            }
            // MakeCircle(145, 38)

            function MakeCirlceAtCurrentPosition() {
                if(mousePosition.x === null || mousePosition.y === null) 
                    return;
                MakeCircle(mousePosition.x, mousePosition.y)
            }


            (function() {
                document.onmousemove = handleMouseMove;
                function handleMouseMove(event) {
                    var eventDoc, doc, body;

                    event = event || window.event; // IE-ism

                    mousePosition.x = event.pageX;
                    mousePosition.y = event.pageY;
                }

                onclick = (event) => { 
                    MakeCirlceAtCurrentPosition();
                };

                onkeyup = (event) => { 
                    if(event.keyCode === 65) {
                        SpeedUpCreation();
                    } 
                    if(event.keyCode === 90) {
                        SlowDownCreation();
                    }
                    if(event.keyCode === 83) {
                        IncreaseBodySize();
                    }
                    if(event.keyCode === 88) {
                        DecreaseBodySize();
                    }
                    if(event.keyCode === 32) {
                        toggleAutoCreation();
                    }
                };
            })();

            var creationTimeDelay = 300;
            var creationTimeDelayStepChange = 20;

            function SpeedUpCreation() {
                if(creationTimeDelay === 0) return;
                creationTimeDelay-= creationTimeDelayStepChange;
                UpdateDisplay();
            }

            function SlowDownCreation() {
                creationTimeDelay+= creationTimeDelayStepChange;
                UpdateDisplay();
            }

            function UpdateDisplay() {
                document.getElementById('speedDisplay').innerHTML = creationTimeDelay;
                document.getElementById('sizeDisplay').innerHTML = bodySize;
                document.getElementById('autoCreationDisplay').innerHTML = autoCreationActive === true ? "active" : "disabled";
                console.log(autoCreationActive);
                console.log(autoCreationActive==true);
            }
            UpdateDisplay();

            function IncreaseBodySize() {
                bodySize+= 1;
                UpdateDisplay();
            }
            function DecreaseBodySize() {
                if(bodySize === 1) return;
                bodySize-= 1;
                UpdateDisplay();
            }

            function toggleAutoCreation() {
                autoCreationActive = !autoCreationActive;
                UpdateDisplay();
            }

            function CreationLoop() {
                if(autoCreationActive) {
                    MakeCirlceAtCurrentPosition();
                }
                setTimeout(function() { CreationLoop() }, creationTimeDelay);
            };
            CreationLoop()
        </script>
    </body>
</html>

